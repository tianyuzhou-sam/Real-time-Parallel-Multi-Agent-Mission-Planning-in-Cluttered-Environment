#!/usr/bin/env python3
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib import colors
with pathmagic.context():
    from Simulator import Simulator


class SimulatorCBBA(Simulator):
    def plot_CBBA_output_path(self, agent_position_index: list, task_position_index: list,
                              AgentList: list, TaskList: list):
        """
        Plot the paths for multiple agents generated by CBBA-Python solver. The paths are not collision-free. 

        Input:
            agent_position_index: a 2D list for agent positions in an index map, [[idx_x_0,idx_y_0], [idx_x_1,idx_y_1], ...]
            task_position_index: a 2D list for task positions in an index map, each sub-list is the task exploring order for each agent, 
                [ [idx_x_task_0,idx_y_task_0, idx_x_task_5,idx_y_task_5, ...] ,[idx_x_task_3,idx_y_task_3, idx_x_task_2,idx_y_task_2, ...], ... ]
            AgentList: a 1D list, each element is an instance of dataclass Agent().
            TaskList: a 1D list, each element is an instance of dataclass Task().
        """
        # number of agents
        num_agents = len(AgentList)
        # number of tasks
        num_tasks = len(TaskList)
        # offset to plot text in 2D space
        offset = (self.map_width - 0) / 100

        # the second figure is with the solved path
        _, ax_2 = plt.subplots(1, 1)
        # plot retangle obstacles
        for idx in range(len(self.obs_left_top_corner_list)):
            # Create a Rectangle patch
            # print(self.obs_left_top_corner_list[idx])
            rect = patches.Rectangle(self.obs_left_top_corner_list[idx], self.size_obs_width, self.size_obs_height, linewidth=1, edgecolor='k', facecolor='k', alpha=0.5)
            # Add the patch to the Axes
            ax_2.add_patch(rect)

        # plot tasks
        for m in range(0, num_tasks):
            # track task is red
            if TaskList[m].task_type == 0:
                color_str = 'red'
            # rescue task is blue
            else:
                color_str = 'blue'
            task_index = self.position_to_map_index([TaskList[m].x, TaskList[m].y])
            ax_2.scatter(task_index[0], task_index[1], marker='x', color=color_str)
            ax_2.text(task_index[0]+offset, task_index[1]+offset, "T"+str(m), fontweight='bold')

        # plot agents
        for n in range(0, num_agents):
            # quad agent is red
            if AgentList[n].agent_type == 0:
                color_str = 'red'
            # car agent is blue
            else:
                color_str = 'blue'
            ax_2.scatter(agent_position_index[n][0], agent_position_index[n][1], marker='o', color=color_str)
            ax_2.text(agent_position_index[n][0]+offset, agent_position_index[n][1]+offset, "A"+str(n), fontweight='bold')
            
            # if the path is not empty
            if (len(task_position_index[n]) > 0.5):
                ax_2.plot([agent_position_index[n][0], task_position_index[n][0]], \
                    [agent_position_index[n][1], task_position_index[n][1]], linewidth=2, color=color_str)

                for i in range(2, len(task_position_index[n]), 2):
                    ax_2.plot([task_position_index[n][i], task_position_index[n][i-2]], \
                        [task_position_index[n][i+1], task_position_index[n][i-1]], linewidth=2, color=color_str)

        plt.title('Agent paths in index map')
        ax_2.set_xlabel("X")
        ax_2.set_ylabel("Y")

        # set legends
        colors = ["red", "red"]
        marker_list = ["o", "x"]
        labels = ["Agent type 1", "Task type 1"]
        f = lambda m,c: plt.plot([],[],marker=m, color=c, ls="none")[0]
        handles = [f(marker_list[i], colors[i]) for i in range(len(labels))]
        # legend for obstacles
        handles.append( patches.Patch(color='black', alpha=0.5) )
        labels.append("Obstacles")
        legend = plt.legend(handles, labels, bbox_to_anchor=(1, 1), loc='upper left', framealpha=1)

        ax_2.set_aspect('equal')
        ax_2.set_xlim([0, self.map_width])
        ax_2.set_ylim([0, self.map_height])
        plt.show(block=False)

    def plot_path_CBBA(self, path_all_agents: list, agent_position_index: list, task_position_index: list, AgentList: list, TaskList: list):
        """
        Plot the paths for multiple agents generated by CBBA-Python solver and DrMaMP Solver. The paths are collision-free.

        Input:
            path_all_agents: a 3D list for paths returned by DrMaMP Solver, i-th sub-list is a 2d path list of agent i, [[idx_x_0,idx_y_0, idx_x_1,idx_y_1, ...], [idx_x_1,idx_y_1, idx_x_3,idx_y_3, ...], ...]
            agent_position_index: a 2D list for agent positions in an index map, [[idx_x_0,idx_y_0], [idx_x_1,idx_y_1], ...]
            task_position_index: a 2D list for task positions in an index map, each sub-list is the task exploring order for each agent, 
                [ [idx_x_task_0,idx_y_task_0, idx_x_task_5,idx_y_task_5, ...] ,[idx_x_task_3,idx_y_task_3, idx_x_task_2,idx_y_task_2, ...], ... ]
            AgentList: a 1D list, each element is an instance of dataclass Agent().
            TaskList: a 1D list, each element is an instance of dataclass Task().
        """

        # number of agents
        num_agents = len(AgentList)
        # number of tasks
        num_tasks = len(TaskList)
        # offset to plot text in 2D space
        offset = (self.map_width - 0) / 100

        # the first figure is without the solved path
        _, ax_map = plt.subplots(1, 1)
        # plot retangle obstacles
        for idx in range(len(self.obs_left_top_corner_list)):
            # Create a Rectangle patch
            # print(self.obs_left_top_corner_list[idx])
            rect = patches.Rectangle(self.obs_left_top_corner_list[idx], self.size_obs_width, self.size_obs_height, linewidth=1, edgecolor='k', facecolor='k', alpha=0.5)
            # Add the patch to the Axes
            ax_map.add_patch(rect)

        # plot tasks
        for m in range(0, num_tasks):
            # track task is red
            if TaskList[m].task_type == 0:
                color_str = 'red'
            # rescue task is blue
            else:
                color_str = 'blue'
            task_index = self.position_to_map_index([TaskList[m].x, TaskList[m].y])
            ax_map.scatter(task_index[0], task_index[1], marker='x', color=color_str)
            ax_map.text(task_index[0]+offset, task_index[1]+offset, "T"+str(m), fontweight='bold')

        # plot agents
        for n in range(0, num_agents):
            # quad agent is red
            if AgentList[n].agent_type == 0:
                color_str = 'red'
            # car agent is blue
            else:
                color_str = 'blue'
            ax_map.scatter(agent_position_index[n][0], agent_position_index[n][1], marker='o', color=color_str)
            ax_map.text(agent_position_index[n][0]+offset, agent_position_index[n][1]+offset, "A"+str(n), fontweight='bold')

        plt.title('Agents in index map')
        ax_map.set_xlabel("X")
        ax_map.set_ylabel("Y")

        # set legends
        colors = ["red", "red"]
        marker_list = ["o", "x"]
        labels = ["Agent type 1", "Task type 1"]
        f = lambda m,c: plt.plot([],[],marker=m, color=c, ls="none")[0]
        handles = [f(marker_list[i], colors[i]) for i in range(len(labels))]
        # legend for obstacles
        handles.append( patches.Patch(color='black', alpha=0.5) )
        labels.append("Obstacles")
        legend = plt.legend(handles, labels, bbox_to_anchor=(1, 1), loc='upper left', framealpha=1)
        ax_map.set_aspect('equal')
        ax_map.set_xlim([0, self.map_width])
        ax_map.set_ylim([0, self.map_height])

        # the second figure is with the solved path
        _, ax_2 = plt.subplots(1, 1)
        # plot retangle obstacles
        for idx in range(len(self.obs_left_top_corner_list)):
            # Create a Rectangle patch
            # print(self.obs_left_top_corner_list[idx])
            rect = patches.Rectangle(self.obs_left_top_corner_list[idx], self.size_obs_width, self.size_obs_height, linewidth=1, edgecolor='k', facecolor='k', alpha=0.5)
            # Add the patch to the Axes
            ax_2.add_patch(rect)

        # plot tasks
        for m in range(0, num_tasks):
            # track task is red
            if TaskList[m].task_type == 0:
                color_str = 'red'
            # rescue task is blue
            else:
                color_str = 'blue'
            task_index = self.position_to_map_index([TaskList[m].x, TaskList[m].y])
            ax_2.scatter(task_index[0], task_index[1], marker='x', color=color_str)
            ax_2.text(task_index[0]+offset, task_index[1]+offset, "T"+str(m), fontweight='bold')

        # plot agents
        for n in range(0, num_agents):
            # quad agent is red
            if AgentList[n].agent_type == 0:
                color_str = 'red'
            # car agent is blue
            else:
                color_str = 'blue'
            ax_2.scatter(agent_position_index[n][0], agent_position_index[n][1], marker='o', color=color_str)
            ax_2.text(agent_position_index[n][0]+offset, agent_position_index[n][1]+offset, "A"+str(n), fontweight='bold')

            if len(path_all_agents[n]) > 0.5:
                for idx_task in range(0, len(path_all_agents[n])):
                    if len(path_all_agents[n][idx_task]) > 0.5:
                        # if the path of n-th task is not empty, plot it
                        path_current_agent = path_all_agents[n][idx_task]
                        ax_2.plot(path_current_agent[0::2], path_current_agent[1::2], linewidth=2, color=color_str)
                    else:
                        # the path of n-th task is empty, link the previous task/agent with dashed line
                        # this is the current empty task
                        task_empty = task_position_index[n][2*idx_task : 2*idx_task+2]

                        if idx_task >= 1:
                            # if task_empty is not the first task, find the previous task
                            task_previous = task_position_index[n][2*idx_task-2 : 2*idx_task]
                        else:
                            # task_empty is the first task, the previous node is the agent itself
                            task_previous = agent_position_index[n]

                        ax_2.plot([task_previous[0],task_empty[0]], [task_previous[1],task_empty[1]], linestyle='dashed', linewidth=2, color='green')
            else:
                print("Agent " + str(n) + " isn't assigned with any task!")

        plt.title('Agent paths in index map')
        ax_2.set_xlabel("X")
        ax_2.set_ylabel("Y")

        # set legends
        colors = ["red", "red"]
        marker_list = ["o", "x"]
        labels = ["Agent", "Task"]
        f = lambda m,c: plt.plot([],[],marker=m, color=c, ls="none")[0]
        handles = [f(marker_list[i], colors[i]) for i in range(len(labels))]

        # add legend about path
        handles.append( plt.plot([],[], color="red", linewidth=2)[0] )
        handles.append( plt.plot([],[], linestyle='dashed', color="green", linewidth=2)[0] )
        handles.append( patches.Patch(color='black', alpha=0.5) )
        labels.extend(["Path", "No Path", "Obstacles"])
        legend = plt.legend(handles, labels, bbox_to_anchor=(1, 1), loc='upper left', framealpha=1)

        ax_2.set_aspect('equal')
        ax_2.set_xlim([0, self.map_width])
        ax_2.set_ylim([0, self.map_height])
        plt.show(block=False)
